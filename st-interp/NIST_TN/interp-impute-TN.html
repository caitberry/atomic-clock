<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>interp-impute-tn</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="interp-impute-TN_files/libs/clipboard/clipboard.min.js"></script>
<script src="interp-impute-TN_files/libs/quarto-html/quarto.js"></script>
<script src="interp-impute-TN_files/libs/quarto-html/popper.min.js"></script>
<script src="interp-impute-TN_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="interp-impute-TN_files/libs/quarto-html/anchor.min.js"></script>
<link href="interp-impute-TN_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="interp-impute-TN_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="interp-impute-TN_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="interp-impute-TN_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="interp-impute-TN_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p>as=hbn— title: “Clock data interpolation TN draft” author: “Thornton” output: bookdown::html_document2 bibliography: References.bib</p>
<hr>
<!--- Open Command Palette: Press F1 or Ctrl + Shift + P to open the command palette.
Run Knit Command: Type rmarkdown: Render and select the desired output format (e.g., HTML, PDF).--->
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>The purpose of this report is to present a methodological approach for applying interpolation techniques to clock frequency data. This report is a result of collaborative research into statistical methods for the analysis of high-precision atomic clock data by the Statistical Engineering Division of the Information Technology Laboratory and the Time and Frequency Division of the Physical Measurement Laboratory.</p>
<p>Because it is such high precision data, the reproducible estimation of atomic clock frequency ratios requires careful attention to data processing steps. The idiosyncrasies of processing clock data that we focus on in this report include options for the treatment of missing data and for the comparison of low frequency data to high frequency data. We describe the nature of these challenges with supporting examples and we present recommendations for addressing these challenges in a transparent, reproducible manner. The example analyses and code in this report are written in Python.</p>
<section id="data-format" class="level2">
<h2 class="anchored" data-anchor-id="data-format">Data Format</h2>
<p>To generate a time series consisting of the ratio (or offset ratio) of two atomic clocks requires the combination of at least four individual time series, two of which are independent of each other and the others. Suppose we are interested in generating a time series for the ratio of an Al+ clock to that of a Yb clock. The two independent series consist of shift data corresponding to each clock. The data files for each clock, Al+ and Yb, contain three variables for each time series, the time stamp (in MJD), the value of the shift (in Hz), and a binary variable, IS_GOOD, denoting whether or not there was a known or suspected issue with the clock readings at that time. The other time series are found in a data file associated with the optical frequency comb. [Are these independent? All output from the same machine?] The columns of the comb data file correspond to frequency readings that can be specific to each clock. Calculating the optical frequencies for each clock based on the ErYb comb, for example, requires time series data corresponding to the three columns labeled fb_Yb_ErYb, fb_Al_ErYb, and SDR:frep_ErYb. [what do these names mean?] The Al+/Yb ratio is then found by adding the clock shift values to the optical frequencies for each clock and then taking the ratio of these sums multiplied by a scalar correction factor.</p>
</section>
<section id="report-organization" class="level2">
<h2 class="anchored" data-anchor-id="report-organization">Report Organization</h2>
<p>The next section presents some background information and intoduces an example data set that will be referenced throughout. Section 3 discusses the initial data processing and exploration steps, Section 4 covers interpolation methods for handling multiple, misaligned data sets, and Section 5 concludes with a summary and by reiterating the steps needed to produce a coherent final data set for estimation and inference of a clock ratio time series.</p>
<!-------------------------------------------------------------->
</section>
</section>
<section id="background" class="level1">
<h1>Background</h1>
<p>The challenge presented here has several layers that complicate a traditional time series analysis. Although the ultimate analysis is of a single time series, let’s call this the target series, the target series is computed based on calculations involving at least three individual time series, we will call these sub-series. Some sub-series may be independent of the others, each may contain missing values, and each is an irregularly sampled time series, possibly at very different frequencies. Furthermore, the sub-series may have slightly or dramatically different start and end times.</p>
<p>The application that motivates this article is the analysis of atomic clock ratio data. In this context, there are at least four sub-series involved in deriving the target series; two independent clock time series consisting of shift values together with an indicator variable representing the quality of each observation and, for each clock, there is another time-series that is observed in accordance with the readings from an optical frequency comb (OFC). The comb experiment produces several time series, two of which match the two clock types used in the ratio target series, the others of which may be used in the calculation of target series based on experimental settings.</p>
<p><span class="citation" data-cites="percival">[Background on modeling clock data @percival - create bib item]</span></p>
<p>[Background on existing work on irregularly sampled time series.] <span class="citation" data-cites="shukla2019">@shukla2019</span> <span class="citation" data-cites="nieto2015">@nieto2015</span> <span class="citation" data-cites="erdogan2005">@erdogan2005</span> <span class="citation" data-cites="eckner2012">@eckner2012</span></p>
<p><span class="citation" data-cites="nieto2015">@nieto2015</span> note that the study of unequally spaced time series can broadly be grouped into several different approaches. The first two dominant approaches are to approach the problem by deriving models for the unequally spaced data as is, or to reduce the irregularly sampled data to equally spaced observations first and then apply standard analysis techniques. The former approach…. Yet another perspective is to view the analysis of unequally spaced time series as a problem of missing data. Methods from this perspective may be evaluated by their ability to predict missing observations <span class="citation" data-cites="nieto2015">[@nieto2015]</span>.</p>
<p><span class="citation" data-cites="pavia2010">@pavia2010</span> provide a thorough review of interpolation techniques with an emphasis on temporal disaggregation and benchmarking. <span class="citation" data-cites="pavia2010">@pavia2010</span> discuss both a temporal perspective and analysis in the frequency domain. In this article, we restrict our focus to analysis in the time domain. In the example application of atomic clock ratio data, the results of interest include estimates of the mean and Allan deviation of the target series. In addition to providing a useful overview of common time series interpolation techniques, <span class="citation" data-cites="lepot2017">@lepot2017</span> also remark upon the assessment of uncertaintites that result from interpolation, noting that the law of propagation of uncertaintites does not apply in this case. In Section 4, we focus our attention on interpolation methods that permit uncertainty quantification since this is of interest to our scientific collaborators.</p>
<p><span class="citation" data-cites="howe2021">[More background on existing methods for univariate time series imputation from @howe2021, @pavia2010, @knotters2010, @eckner2012]</span></p>
<p>[Background on mixed frequency data analysis]</p>
<p>[Background on existing approaches for combining time series i.e.&nbsp;convolution of time series]</p>
<!-------------------------------------------------------------->
</section>
<section id="data-processing-and-exploration" class="level1">
<h1>Data Processing and Exploration</h1>
<section id="data-processing" class="level2">
<h2 class="anchored" data-anchor-id="data-processing">Data Processing</h2>
<p>There are two main processing steps that must be preformed before the data can be analysed. First, all signal data, including constants for correction factors, must be converted to high precision decimal types in Python. [add sentence or two about this]<br>
Second, each clock’s shift data must be filtered to remove any data deemed poor quality based on the IS_GOOD variable. [add sentence about this and example code chunk]</p>
</section>
<section id="visualize-missing-data" class="level2">
<h2 class="anchored" data-anchor-id="visualize-missing-data">Visualize Missing Data</h2>
<p>Data visualization is an important first step to identify any missing data or unexpected patterns. It is crucial that individual time series are visualized before they are combined. This step also helps with the determination of identifying the overlapping window of observations which is the topic of the next section.</p>
<p>To understand the magnitude of any missing data issues, one can count the missing observations in each time series. For example, the following Python code reports the total number of missing data points (i.e.&nbsp;truly empty or null data values) in <code>myseries</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(myseries.isna().<span class="bu">sum</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Another useful summary is the length of the longest sequence of missing values. The code below calculates the longest sequence (<code>max_streak</code>) of missing values in <code>myseries</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>is_na <span class="op">=</span> myseries.isna()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>max_streak <span class="op">=</span> current_streak <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> val <span class="kw">in</span> is_na:</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> val:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        current_streak <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        max_streak <span class="op">=</span> <span class="bu">max</span>(max_streak, current_streak)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        current_streak <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Longest sequence of NaNs:"</span>, max_streak, <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>While these numerical summaries of missing values are informative, they are not enough to identify any unusual patterns of missingness. For this, there is no substitute for a visual analysis of the data. A useful Python package for visualizing missing data is the package “missingno” which can be implemented on a data frame, <code>time_series_data</code>, as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> missingno <span class="im">as</span> msno</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>msno.matrix(time_series_data)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The treatment of long sequences of missing data is distinct from the treatment of individual missing data points. While common imputation techniques for univariate time series can be implemented for individual missing values, long sequences of missing values indicate a need to reconsider the start and end times for each sub-series. This is the topic of the next subsection. Discussed in more detail later, interpolation techniques may be applied to impute individual missing data values. The only distinction between imputation and interpolation in this context is a matter of perspective as <span class="citation" data-cites="nieto2015">@nieto2015</span> remark that “unevenly spaced time series have also been treated as equally spaced time series with missing observations.”</p>
</section>
<section id="determine-overlapping-window-of-observation" class="level2">
<h2 class="anchored" data-anchor-id="determine-overlapping-window-of-observation">Determine Overlapping Window of Observation</h2>
<p>An important characteristic of clock and comb data is that the beginning and end point of observations may vary among sub-series. If there are any large gaps of missing data in the clock shift files, this should also be taken into consideration when determining the start and end time points of the data. [This may not be what to recommend. Need to think about the scope.] Therefore, a necessary component to preparing the data for analysis is first identifying the overlapping windows of observation for each time series. The goal of this step is to find a time interval <span class="math inline">\([t_{i}, t_{j}]\)</span> that includes the largest possible intersection of non-missing observations from each sub-series.</p>
<p>Consider the figure below which marks the start and end points of observations for each sub-series, a time series of comb data, a time series from two different atomic clocks. If there are no large gaps of missing values in any of these series, the largest window of observation for the target series (which in this case is a ratio of the two clock values) begins at the first time point of the comb series and ends at the last time point of Clock 1’s series. Even though there are more observations outside of this range, these observations cannot be used because values from each time series are necessary to construct the target series.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="interp-impute-TN_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Example start and end times relative to one another for two clock time series and for the observations from an optical frequency comb.</figcaption>
</figure>
</div>
</div>
</div>
<p>For this reason, the target time series cannot be computed over any time intervals containing sequentially missing values for one or more of the sub-series. It is more accurate in such cases to consider data before and after a large gap as separate time series with smaller sample sizes. Thus, in the case where a sub-series contains at least one large gap of missing values, the final overlapping window of observation will be considerably smaller as will the target series sample size. [Reiterate note about how keeping missing values until the end is not a valid approach - even if it can be computed with software.]</p>
<p>In addition to visualizing the sub-series, the follow Python functions may be useful for detecting the overlapping window of observation for the target series.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extracts series element that is as close to the target as possible without going over.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lb_extract(target, data):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    inx <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    stopper <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> stopper <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> data[inx] <span class="op">&lt;=</span> target:</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            inx <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> inx  </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Extracts series element that is as close to target as possible without going under.  </span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ub_extract(target, data):</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    inx <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    stopper <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> stopper <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> data[<span class="bu">len</span>(data)<span class="op">-</span>inx] <span class="op">&gt;=</span> target:</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            inx <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">len</span>(data)<span class="op">-</span>inx </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<!-------------------------------------------------------------->
</section>
</section>
<section id="interpolation" class="level1">
<h1>Interpolation</h1>
<section id="frequency-alignment" class="level2">
<h2 class="anchored" data-anchor-id="frequency-alignment">Frequency Alignment</h2>
<p>The culmination of the previous data processing steps yields several complete sub-series (i.e.&nbsp;that have no missing values) that begin and end at the same time points but that may be observed with very different, and irregular, frequencies. Because each series is comprised of observations along a distinct, irregular time scale, we are not yet ready to compute the target series. In the context of atomic clock data, the comb time series are typically observed more regularly than any individual clock shift time series. Thus the comb data represent a high-frequency sub-series and the clock shift data are low-frequency sub-series in comparison. Furthermore, it may be the case that each clock sub-series is sampled at very different rates.</p>
<p>Without loss of generality and for the sake of illustration, let us suppose that we are constructing a target series from an optical frequency comb sub-series and two clock sub-series. Suppose further that Clock 1 is observed with either a similar or a lower frequency than Clock 2 and that Clock 2 is observed with a similar frequency as the comb sub-series. Symbolically, we are assuming <span class="math inline">\(n_{C1} \leq n_{C2} \approx n_{OFC}\)</span>. In this context, the target series is a ratio time series for any two clocks. To derive the target series, the time points of observations for each sub-series must be in alignment with one another. That is, the times of observation for each series, <span class="math inline">\(t_{C1,i} = t_{C2,i} = t_{OFC,i}\)</span> for <span class="math inline">\(i = 1, \dots, n\)</span>. Note that this alignment condition can be met even if the series are irregularly sampled; irregular sampling for, say, Clock 1 would simply mean that <span class="math inline">\((t_{C1, i+1} - t_{C1, i})\)</span> is not equal for all <span class="math inline">\(i \in \{2, \dots, n_{C1}\}\)</span>. Here we give an overview of several methodological approaches one may take to align each series.</p>
<p><strong>Method 1</strong>: Align Clock 1 with the observations of the comb. Then align Clock 2 with the observations of the comb. Proceed to derive the ratio time series for analysis. The result of this approach will be a time series with the same irregularities in sampling as the comb series.</p>
<!---**Method 2**: Align Clock 1 with the observations of Clock 2. Then align the new series for Clock 1 with the comb. Finally, align Clock 2 with the comb and proceed to derive the ratio time series for analysis. This approach may be reasonable if Clock 1 is observed with a much lower frequency compared to Clock 2. As with Method 1, the result will be a time series with the same irregular observation pattern as the comb data. --->
<p><strong>Method 2</strong>: Realign the comb time series so that the observations are regularly sampled along the time interval of interest, i.e so that <span class="math inline">\((t_{OFC, i+1} - t_{OFC,i})\)</span> are equal for all <span class="math inline">\(i \in \{2, \dots, n_{OFC}\}\)</span>. Align Clock 1 with the new comb series. Align Clock 2 with the new comb series. Proceed to derive the ratio time series for analysis. The result of this approach will be a regularly sampled time series.</p>
<p><strong>Method 3</strong>: Align Clock 1 with the observations of Clock 2. Then align the comb with Clock 2. Proceed to derive the ratio time series for analysis. The result of this approach will be a target series with the same irregularities in sampling as in Clock 2. This approach essentially disregards (or masks) comb data for the sake of matching the observational time points of Clock 2.</p>
<p><strong>Method 4</strong>: Realign the time series from Clock 2 so that the observations are regularly sampled along the time interval of interest, i.e so that <span class="math inline">\((t_{C2, i+1} - t_{C2,i})\)</span> are equal for all <span class="math inline">\(i \in \{2, \dots, n_{C2}\}\)</span>. Align Clock 1 with the new series for Clock 2. Align the comb series with the new series for Clock 2. Proceed to derive the ratio time series for analysis. The result of this approach will be a regularly sampled time series.</p>
<p>Note that none of the methods listed above suggest realigning a high frequency series to match a low frequency series (aggregating). This is because such an approach would sacrifice valuable information contained in the higher frequency series without serving a practical purpose in the context of our example. <!---and thus is generally not advisable. Within the context of this example where---> When the target series is a ratio of data from two separate clocks, it is worth considering how variable the values in the comb sub-series are. If these values are relatively constant, with practically negligible variability in the values associated with each clock, then Methods 3 and 4 may be preferable to Methods 1 and 2 because masking the values from the comb sub-series will be of little to no consequence. <!---Although it is listed above for the sake of completeness, Method 2 is inferior to the other methods because it results in an irregularly sampled time series and it requires three separate interpolation steps. In comparison,--> Methods 1 and 3 only require two separate interpolation steps. The drawback of these two methods, however is that the resulting time series is still irregularly observed. “A comparative analysis of time series is not feasible if the observation times are different <span class="citation" data-cites="nieto2015">@nieto2015</span>.” “Any attempt of comparative or associative analysis between… two time series requires them to have both been measured at the same times <span class="citation" data-cites="nieto2015">@nieto2015</span>.” However, if the sampling irregularities of the target series are so small that that are practically meaningless, then these approaches are preferable to the others because they require fewer interpolation steps.</p>
<p>Methods 2 and 4, on the other hand, each require three separate interpolation steps. The advantage of these methods is that they result in a regularly sampled target series. Although it is possible (and perhaps preferable) to coherently analyse an irregularly sampled time series in the time domain (see e.g. <span class="citation" data-cites="eckner2012">@eckner2012</span>), this is not an approach that is in popular use. <span class="citation" data-cites="eckner2019">@eckner2019</span> has developed software to implement an analysis on irregularly sampled time series in the C library “utsAlgorithms” and the R package “utsOperators”. Example implementations for each of these four methods are included in next subsection.<br>
<!---Depending on the type of analysis, having an irregularly sampled time series may or may not be of concern. For example, if the analysis is based upon a multitaper spectral approach such as that in [cite clock paper], then the sampling irregularities do not present an issue. [cite sources as to why not]. However, if the analysis is to proceed in [the time domain?], irregularities in the observational frequency of the time series will bias common estimates of interest such as the mean and AVAR. [cite sources]---></p>
</section>
<section id="interpolation-techniques" class="level2">
<h2 class="anchored" data-anchor-id="interpolation-techniques">Interpolation techniques</h2>
<p>Once a method for alignment is determined, the implementation of the alignment will occur through time series interpolation. There are many different techniques for interpolating time series data. [Cite some sources.]</p>
<p><span class="citation" data-cites="pavia2010">@pavia2010</span> section 6 on kalman filter method (others don’t seem applicable)</p>
<p><span class="citation" data-cites="lepot2017">@lepot2017</span> categorize two general interpolation approaches, deterministic and stochastic. Popular deterministic approaches include nearest-neighbor interpolation, polynomial interpolation, interpolation through distance weighting, and interpolation through signal analysis. Stochastic interpolation techniques include regression methods, autoregressive methods, machine learning methods, methods based on data dynamics and methods based on kriging. Although extensive, these lists of approaches are far from exhaustive as this is an active area of statistical research and interpolation is a highly customizable proceedure. “The ranking of desirable [interpolation] methods (obtained through a trade-off of criteria) could be strongly dependent on the size of the gaps, and the nature of recorded phenomena and data <span class="citation" data-cites="lepot2017">[@lepot2017]</span>.”</p>
<p><span class="citation" data-cites="knotters2010">@knotters2010</span> provide another useful summary of a collection of interpolation techniques, specifically for use in environmental research. In particular, they remark upon the quantification of the accuracy of interpolated values and the incorporation of process knowledge (among other factors) which are relevant in the context of clock data. Importantly, they highlight that validation studies are necessary to assess the quality of interpolation studies.</p>
<p>For interpolation in time, and for methods that quantify uncertainty without depending on ancillary information, <span class="citation" data-cites="knotters2010">@knotters2010</span> discuss methods based on kriging, ARIMA modelling, a state-space approach and Kalman filtering, and minimum mean absolute error linear interpolation (MMAELI). Model based interpolation approaches (e.g.&nbsp;ARIMA for transfer function-noise models) are appropriate for time series that are regularly observed. Kalman filterning or smoothing however, can be applied to interpolate irregularly observed time series <span class="citation" data-cites="knotters2010">[@knotters2010]</span>. Although there are many more interpolation techniques covered in <span class="citation" data-cites="knotters2010">@knotters2010</span>, for the application to clock ratio data, we are not concerned with interpolation in space or space-time nor are we concerned with methods that do not quantify uncertainty about the interpolated values. Furthermore, we do not suppose that ancillary information is available. (see section 3.1.3 and 3.2 as well)</p>
<p>aggregation (or upscaling) is the process of transferring information from a more detailed scale to a coarser scale. and disaggregation (downscaling) time series (section 6); software in section 7</p>
<p><span class="citation" data-cites="nieto2015">@nieto2015</span></p>
<p>[mention and demonstrate use of python packages]</p>
<p>For the convolution of univariate time series…</p>
<p><strong>Example implementation of Method 1.</strong> We will compare two analysese of a clock ratio time series in this example. The first analysis (a) ignores the irregular sampling of the time series. The second analysis (b) makes use of the R package “utsOperators” to derive estimators that take into account the irregularies in sampling.</p>
<p><strong>Example implementation of Method 2.</strong></p>
<p><strong>Example implementation of Method 3.</strong> We will compare two analysese of a clock ratio time series in this example. The first analysis (a) ignores the irregular sampling of the time series. The second analysis (b) makes use of the R package “utsOperators” to derive estimators that take into account the irregularies in sampling.</p>
<p><strong>Example implementation of Method 4.</strong></p>
<!-------------------------------------------------------------->
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>[Summarize the results of the examples in the previous section]</p>
<p>The process we have outlined for aligning the observational frequency of clock time series follows these steps:</p>
<p>Step 1) Process the data for each time series to determine the final window of observation and exclude low-quality data.</p>
<p>Step 2) Determine if there are any missing data and decide whether or not to impute values that are missing.</p>
<p>Step 3) Determine which method of frequency alignment will be used and decide upon an interpolation technique to implement the alignment.</p>
<p>Calculate clock frequencies by adding together comb frequencies and shift data, scaled by the total correction amount</p>
<p>[all of this analysis is occurring within the time domain? not the frequency domain?]</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>